const formatDate = (time) => {
    const d = new Date(time);
    return `on ${d.toLocaleDateString()} at ${d.toLocaleTimeString()}`
}

const vue = new Vue({
  el: "#entry-container",
  data: {
    editor: new FingeringEditor(#{renderId}),
    infer_weights: #{jsStartingWeights},
    description: #{entryDescription entry},
    uploadedBy: `Uploaded by #{rawJS uploadedByName} ${formatDate(#{time})}`,
    validated: false,
    edited: false,
    loading: false,
    show_alert: false,
    alert_message: "",
    disable_submit: true,
    simulation: null,
  },

  computed: {
    infer_weights_map: function() {
      let m = {};
      this.infer_weights.forEach(({ name, value }) => m[name] = value);
      return m;
    }
  },

  mounted: function() {
    // the xml on the server already has measure numbers set
    this.editor.render(#{entryMusicxml entry}, 1);
  },

  methods: {
    async inferFingerings(e) {
      this.show_alert = false;
      const s = new XMLSerializer();
      const body = {
        infer_xml: s.serializeToString(this.editor.musicxml),
        infer_weights: this.infer_weights_map,
      };
      this.loading = true;
      try {
        const resp = await fetch("@{InferR}", {
          method: "POST",
          headers: { "Content-Type": "application/json", "X-XSRF-TOKEN": #{csrf} },
          body: JSON.stringify(body)
        });
        const json = await resp.json();
        this.loading = false;
        if (json.error) {
          this.alert_message = json.error;
          this.show_alert = true;
          return;
        }
        if (json.success) {
          this.description = `Inferred. Cost: ${json.cost}`;
          this.editor.clear();
          this.editor.render(json.xml, 1);
          return;
        }
      } catch (e) {
        this.alert_message = e;
        this.show_alert = true;
        return;
      }
    },

    async inferWeights() {
      this.show_alert = false;
      const s = new XMLSerializer();
      const body = {
        infer_xml: s.serializeToString(this.editor.musicxml),
        infer_weights: this.infer_weights_map,
      };
      this.loading = true;
      try {
        const resp = await fetch("@{InferWeightsR}", {
          method: "POST",
          headers: { "Content-Type": "application/json", "X-XSRF-TOKEN": #{csrf} },
          body: JSON.stringify(body)
        });
        const json = await resp.json();
        this.loading = false;
        if (json.error) {
          this.alert_message = json.error;
          this.show_alert = true;
          return;
        }
        if (json.success) {
          this.infer_weights = json.infer_weights;
          return;
        }
      } catch (e) {
        this.alert_message = e;
        this.show_alert = true;
        this.loading = false;
        return;
      }
    },

    async showVisualization() {
      this.show_alert = false;
      const s = new XMLSerializer();
      const body = {
        infer_xml: s.serializeToString(this.editor.musicxml),
        infer_weights: this.infer_weights_map,
      };
      this.loading = true;
      try {
        const resp = await fetch("@{VisualizeR}", {
          method: "POST",
          headers: { "Content-Type": "application/json", "X-XSRF-TOKEN": #{csrf} },
          body: JSON.stringify(body)
        });
        const json = await resp.json();
        this.loading = false;
        if (json.success) {
          console.log(json.graph);
          let { nodes, links, n_steps } = json.graph;
          let svg = d3.select("svg#visualization");
          const width = document.getElementById(#{renderId}).offsetWidth;
          const height = 800;
          const radius = 5;
          svg.attr('width', width).attr('height', height);
          const ticked = () => {
            svg
              .selectAll('circle')
              .data(nodes)
              .join('circle')
              .attr('r', radius)
              .style('fill', 'orange')
              .attr('cx', d => d.x)
              .attr('cy', d => d.y);
            svg
              .selectAll('line')
              .data(links)
              .join('line')
              .attr('stroke', '#999')
              .attr('x1', l => l.source.x)
              .attr('y1', l => l.source.y)
              .attr('x2', l => l.target.x)
              .attr('y2', l => l.target.y)
              .attr('opacity', 0.6)
              .attr('stroke-width', 1);
          };
          for (let node of nodes) {
            node.fx = node.fx * (width / (1 + n_steps)) + radius
          };
          this.simulation = d3.forceSimulation(nodes)
              .force("link", d3.forceLink(links))
              // .force("charge", d3.forceManyBody())
              .force("collide", d3.forceCollide().radius(3*radius))
              .force("center", d3.forceCenter(width / 2, height / 2))
              .on("tick", ticked);
          return;
        }
      } catch (e) {
        this.alert_message = e;
        this.show_alert = true;
        this.loading = false;
        return;
      }
    },

    async submit(e) {
      if (!this.description) {
        this.validated = true;
        return;
      }
      const s = new XMLSerializer();
      const body = {
        movement_id: #{toJSON (fromSqlKey (entryMovementId entry))},
        part: #{showPart (entryPart entry)},
        start_measure: #{toJSON (entryMeasure_start entry)},
        xml: s.serializeToString(this.editor.musicxml),
        description: this.description
      };
      this.loading = true;
      const resp = await fetch("@{UploadR}", {
        method: "POST",
        headers: { "Content-Type": "application/json", "X-XSRF-TOKEN": #{csrf} },
        body: JSON.stringify(body)
      });
      const json = await resp.json();
      if (json.error) {
        this.alert_message = json.error;
        this.show_alert = true;
        this.loading = false;
        return;
      }
      if (json.success) {
        window.location.href = `/entry/${json.entry_id}`;
      }
    }
  },

  watch: {
    loading: function(loading) {
      // works better than calling editor.enable() or editor.disable()
      // but I don't like it
      this.editor.enabled = !loading;
    },
  },
})
