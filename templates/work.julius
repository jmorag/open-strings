const vue = new Vue({
  el: "##{rawJS wId}",
  data: {
    work_id: #{jsWorkId},
    start_measure: "", // usually a number, but should be displayed as empty on paint
    movements: #{movements},
    movement_id: (#{movements})[0].value,
    parts: #{parts},
    part: (#{parts})[0],
    infer_weights: #{startingWeights},
    xml_file: null,
    table_fields: [
      "movement",
      "part",
      "measures",
      "description",
      {
        key: "uploaded_by",
        formatter: ({ user, time }) => {
          const d = new Date(time);
          return `${user} on ${d.toLocaleDateString()} at ${d.toLocaleTimeString()}`;
        }
      }
    ],
    entries: #{entries},
    editor: new FingeringEditor(#{renderId}),
    description: "",
    loading: false,
    show_alert: false,
    alert_message: "",
    show_success: false,
    disable_change_start: false,
    disable_submit: true,
    show_editor: false,
    show_instructions: false,
    validated: false
  },

  mounted: async function() {
    const index = this.entries.findIndex(e => e.entry_id === #{entryId});
    if (index !== -1) {
      this.$refs.table.selectRow(index);
      await this.fetchXml(this.entries[index]);
    }
  },

  methods: {
    async infer(e) {
      const s = new XMLSerializer();
      const body = {
        infer_xml: s.serializeToString(this.editor.musicxml),
        infer_weights: this.infer_weights,
      };
      this.loading = true;
      try {
        const resp = await fetch("@{InferR}", {
          method: "POST",
          headers: { "Content-Type": "application/json", "X-XSRF-TOKEN": #{csrf} },
          body: JSON.stringify(body)
        });
        const json = await resp.json();
        this.loading = false;
        if (json.error) {
          this.alert_message = json.error;
          this.show_alert = true;
          return;
        }
        if (json.success) {
          this.description = "Inferred";
          this.editor.clear()
          this.renderXml(new Blob([json.xml])); // TODO: make this better
          return;
        }
      } catch (e) {
        this.alert_message = `${e}`;
        this.show_alert = true;
        return;
      }
    },

    async submit(e) {
      if (!this.start_measure || !this.description) {
        this.validated = true;
        return;
      }
      const s = new XMLSerializer();
      const body = {
        movement_id: this.movement_id,
        part: this.part,
        start_measure: this.start_measure,
        xml: s.serializeToString(this.editor.musicxml),
        description: this.description
      };
      this.loading = true;
      const resp = await fetch("@{UploadR}", {
        method: "POST",
        headers: { "Content-Type": "application/json", "X-XSRF-TOKEN": #{csrf} },
        body: JSON.stringify(body)
      });
      const json = await resp.json();
      this.loading = false;
      if (json.error) {
        this.alert_message = json.error;
        this.show_alert = true;
        return;
      }
      if (json.success) {
        this.show_success = true;
        await this.fetchEntries(); // update table
        return;
      }
    },
    async fetchXml(item, _index, _event) {
      this.xml_file = null;
      this.movement_id = item.movement_id;
      this.part = item.part;
      this.start_measure = item.start_measure;
      this.description = item.description;
      this.loading = true;
      const resp = await fetch(`/api/musicxml/${item.entry_id}`);
      if (resp.status === 404) {
        this.alert_message = "Error retrieving MusicXML";
        this.show_alert = true;
        this.loading = false;
        return;
      }
      const blob = await resp.blob();
      this.renderXml(blob);
      this.loading = false;
    },
    renderXml(file) {
      if (file) {
        const reader = new FileReader();
        reader.readAsText(file);
        reader.onload = async ({ target: { result } }) => {
          try {
            await this.editor.render(result, this.start_measure);
          } catch (e) {
            this.editor.clear();
            this.alert_message =
              "Grace notes currently cannot be rendered due to an <a href='https://github.com/opensheetmusicdisplay/opensheetmusicdisplay/issues/878'>upstream bug</a>";
            this.show_alert = true;
            return;
          }
          this.show_editor = true;
          this.disable_submit = false;
        };
      } else {
        this.disable_submit = true;
        this.editor.clear();
      }
    },
    clear() {
      this.start_measure = "";
      this.xml_file = null;
      this.show_editor = false;
      this.show_alert = false;
      this.editor.clear();
      this.$refs.table.clearSelected();
    },
    async fetchEntries() {
      const resp = await fetch("@{EntriesR work_key}");
      this.entries = await resp.json();
    }
  },
  watch: {
    xml_file: function(val) {
      this.$refs.table.clearSelected();
      this.show_alert = false;
      this.renderXml(val);
    }
  }
});
